{"version":3,"file":"avalanche-js-transaction.cjs.production.min.js","sources":["../src/types.ts","../src/utils.ts","../src/transactionBase.ts","../src/transaction.ts","../src/shardingTransaction.ts","../src/factory.ts"],"sourcesContent":["/**\n # avalanche-js-transaction\n\nThis package provides a collection of apis to create, sign/send transaction, and receive confirm/receipt.\n\n## Installation\n\n```\nnpm install avalanche-js-transaction\n```\n\n## Usage\n\nCreate a Avalanche instance connecting to testnet\n\n```javascript\n* const { Avalanche } = require('avalanche-js-core');\n* const {\n*   ChainID,\n*   ChainType,\n*   hexToNumber,\n*   numberToHex,\n*   fromWei,\n*   Units,\n*   Unit,\n* } = require('avalanche-js-utils');\n\n* const hmy = new Avalanche(\n*     'https://api.s0.b.hmny.io/',\n*     {\n*         chainType: ChainType.Avalanche,\n*         chainId: ChainID.HmyTestnet,\n*     },\n* );\n```\n\nCreating a new transaction using parameters\n```javascript\n* const txn = hmy.transactions.newTx({\n*   to: 'avax166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n*   value: new Unit(1).asAVAX().toWei(),\n*   // gas limit, you can use string\n*   gasLimit: '21000',\n*   // send token from shardID\n*   shardID: 0,\n*   // send token to toShardID\n*   toShardID: 0,\n*   // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n*   gasPrice: new hmy.utils.Unit('1').asGwei().toWei(),\n* });\n```\n\nRecovering transaction from raw transaction hash\n```javascript\n* const raw = '0xf86d21843b9aca00825208808094d6ba69da5b45ec98b53e3258d7de756a567b6763880de0b6b3a76400008028a0da8887719f377401963407fc1d82d2ab52404600cf7bea37c27bd2dfd7c86aaaa03c405b0843394442b303256a804bde835821a8a77bd88a2ced9ffdc8b0a409e9';\n* const tx = hmy.transactions.recover(raw);\n```\n\nGetting the RLP encoding of a transaction (rawTransaction), along with raw transaction field values that were encoded\n```javascript\n* const [encoded, raw] = txn.getRLPUnsigned()\n```\n\nSign the transaction using a wallet and send the transaction, wait for confirmation and print receipt\n```javascript\n* // key corresponds to avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7, only has testnet balance\n* hmy.wallet.addByPrivateKey('45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e');\n\n* hmy.wallet.signTransaction(txn).then(signedTxn => {\n*   signedTxn.sendTransaction().then(([tx, hash]) => {\n*     console.log('tx hash: ' + hash);\n*     signedTxn.confirm(hash).then(response => {\n*       console.log(response.receipt);\n*     });\n*   });\n* });\n```\n\nAsynchronous transaction sign, send, and confirm\n```javascript\n* async function transfer() {\n*   hmy.wallet.addByPrivateKey('45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e');\n\n*   const signedTxn = await hmy.wallet.signTransaction(txn);\n*   signedTxn\n*     .observed()\n*     .on('transactionHash', (txnHash) => {\n*       console.log('');\n*       console.log('--- hash ---');\n*       console.log('');\n*       console.log(txnHash);\n*       console.log('');\n*     })\n*     .on('receipt', (receipt) => {\n*       console.log('');\n*       console.log('--- receipt ---');\n*       console.log('');\n*       console.log(receipt);\n*       console.log('');\n*     })\n*     .on('cxReceipt', (receipt) => {\n*       console.log('');\n*       console.log('--- cxReceipt ---');\n*       console.log('');\n*       console.log(receipt);\n*       console.log('');\n*     })\n*     .on('error', (error) => {\n*       console.log('');\n*       console.log('--- error ---');\n*       console.log('');\n*       console.log(error);\n*       console.log('');\n*     });\n\n*   const [sentTxn, txnHash] = await signedTxn.sendTransaction();\n\n*   const confiremdTxn = await sentTxn.confirm(txnHash);\n\n*   // if the transactino is cross-shard transaction\n*   if (!confiremdTxn.isCrossShard()) {\n*     if (confiremdTxn.isConfirmed()) {\n*       console.log('--- Result ---');\n*       console.log('');\n*       console.log('Normal transaction');\n*       console.log(`${txnHash} is confirmed`);\n*       console.log('');\n*       console.log('please see detail in explorer:');\n*       console.log('');\n*       console.log('https://explorer.testnet.avalanche.avax/#/tx/' + txnHash);\n*       console.log('');\n*       process.exit();\n*     }\n*   }\n*   if (confiremdTxn.isConfirmed() && confiremdTxn.isCxConfirmed()) {\n*     console.log('--- Result ---');\n*     console.log('');\n*     console.log('Cross-Shard transaction');\n*     console.log(`${txnHash} is confirmed`);\n*     console.log('');\n*     console.log('please see detail in explorer:');\n*     console.log('');\n*     console.log('https://explorer.testnet.avalanche.avax/#/tx/' + txnHash);\n*     console.log('');\n*     process.exit();\n*   }\n* }\n* transfer();\n```\n *\n * @packageDocumentation\n * @module avalanche-transaction\n */\n\nimport { BN, Signature } from 'avalanche-js-crypto';\n\nexport interface TxParams {\n  id: string;\n  from: string;\n  to: string;\n  nonce: number | string;\n  gasLimit: number | string | BN;\n  gasPrice: number | string | BN;\n  shardID: number | string;\n  toShardID: number | string;\n  data: string;\n  value: number | string | BN;\n  chainId: number;\n  rawTransaction: string;\n  unsignedRawTransaction: string;\n  signature: Signature;\n  receipt?: TransasctionReceipt;\n}\n\nexport enum TxStatus {\n  NONE = 'NONE',\n  INTIALIZED = 'INITIALIZED',\n  SIGNED = 'SIGNED',\n  PENDING = 'PENDING',\n  CONFIRMED = 'CONFIRMED',\n  REJECTED = 'REJECTED',\n}\n\nexport interface TransasctionReceipt {\n  transactionHash: string;\n  transactionIndex: string;\n  blockHash: string;\n  blockNumber: string; // 11\n  from: string;\n  to: string;\n  gasUsed: string;\n  cumulativeGasUsed: string; // 13244\n  contractAddress?: string | null; // or null, if none was created\n  logs: any[];\n  logsBloom: string; // 256 byte bloom filter\n  v: string;\n  r: string;\n  s: string;\n  responseType?: string;\n  byzantium?: boolean;\n  status?: string; // post Byzantium will return `0x0` or `0x1`\n  root?: string; // pre Byzantium will return `root`\n}\n","/**\n * @packageDocumentation\n * @module avalanche-transaction\n * @hidden\n */\n\nimport { hexToNumber, isHex, isAddress, strip0x, ChainType } from 'avalanche-js-utils';\nimport {\n  decode,\n  encode,\n  keccak256,\n  hexlify,\n  BN,\n  hexZeroPad,\n  recoverAddress,\n  Signature,\n  getAddress,\n  sign,\n} from 'avalanche-js-crypto';\nimport { HttpProvider, Messenger } from 'avalanche-js-network';\nimport { TxParams } from './types';\nimport { Transaction } from './transaction';\n\nexport const transactionFields = [\n  { name: 'nonce', length: 32, fix: false },\n  { name: 'gasPrice', length: 32, fix: false, transform: 'hex' },\n  { name: 'gasLimit', length: 32, fix: false, transform: 'hex' },\n  { name: 'shardID', length: 16, fix: false },\n  // recover it after main repo fix\n  { name: 'toShardID', length: 16, fix: false },\n  { name: 'to', length: 20, fix: true },\n  { name: 'value', length: 32, fix: false, transform: 'hex' },\n  { name: 'data', fix: false },\n];\n\nexport const transactionFieldsETH = [\n  { name: 'nonce', length: 32, fix: false },\n  { name: 'gasPrice', length: 32, fix: false, transform: 'hex' },\n  { name: 'gasLimit', length: 32, fix: false, transform: 'hex' },\n  { name: 'to', length: 20, fix: true },\n  { name: 'value', length: 32, fix: false, transform: 'hex' },\n  { name: 'data', fix: false },\n];\n\nexport const handleNumber = (value: string) => {\n  if (isHex(value) && value === '0x') {\n    return hexToNumber('0x00');\n  } else if (isHex(value) && value !== '0x') {\n    return hexToNumber(value);\n  } else {\n    return value;\n  }\n};\n\nexport const handleAddress = (value: string): string => {\n  if (value === '0x') {\n    return '0x';\n  } else if (isAddress(value)) {\n    return value;\n  } else {\n    return '0x';\n  }\n};\n\nexport const recover = (rawTransaction: string) => {\n  const transaction = decode(rawTransaction);\n  if (transaction.length !== 11 && transaction.length !== 8) {\n    throw new Error('invalid rawTransaction');\n  }\n\n  const tx: TxParams = {\n    id: '0x',\n    from: '0x',\n    rawTransaction: '0x',\n    unsignedRawTransaction: '0x',\n    nonce: new BN(strip0x(handleNumber(transaction[0]))).toNumber(),\n    gasPrice: new BN(strip0x(handleNumber(transaction[1]))),\n    gasLimit: new BN(strip0x(handleNumber(transaction[2]))),\n    shardID: new BN(strip0x(handleNumber(transaction[3]))).toNumber(),\n    toShardID: new BN(strip0x(handleNumber(transaction[4]))).toNumber(),\n    to:\n      handleAddress(transaction[5]) !== '0x'\n        ? getAddress(handleAddress(transaction[5])).checksum\n        : '0x',\n    value: new BN(strip0x(handleNumber(transaction[6]))),\n    data: transaction[7],\n    chainId: 0,\n    signature: {\n      r: '',\n      s: '',\n      recoveryParam: 0,\n      v: 0,\n    },\n  };\n\n  // Legacy unsigned transaction\n  if (transaction.length === 8) {\n    tx.unsignedRawTransaction = rawTransaction;\n    return tx;\n  }\n\n  try {\n    tx.signature.v = new BN(strip0x(handleNumber(transaction[8]))).toNumber();\n  } catch (error) {\n    throw error;\n  }\n\n  tx.signature.r = hexZeroPad(transaction[9], 32);\n  tx.signature.s = hexZeroPad(transaction[10], 32);\n\n  if (\n    new BN(strip0x(handleNumber(tx.signature.r))).isZero() &&\n    new BN(strip0x(handleNumber(tx.signature.s))).isZero()\n  ) {\n    // EIP-155 unsigned transaction\n    tx.chainId = tx.signature.v;\n    tx.signature.v = 0;\n  } else {\n    // Signed Tranasaction\n\n    tx.chainId = Math.floor((tx.signature.v - 35) / 2);\n    if (tx.chainId < 0) {\n      tx.chainId = 0;\n    }\n\n    let recoveryParam = tx.signature.v - 27;\n\n    const raw = transaction.slice(0, 8);\n\n    if (tx.chainId !== 0) {\n      raw.push(hexlify(tx.chainId));\n      raw.push('0x');\n      raw.push('0x');\n      recoveryParam -= tx.chainId * 2 + 8;\n    }\n\n    const digest = keccak256(encode(raw));\n    try {\n      const recoveredFrom = recoverAddress(digest, {\n        r: hexlify(tx.signature.r),\n        s: hexlify(tx.signature.s),\n        recoveryParam,\n      });\n      tx.from = recoveredFrom === '0x' ? '0x' : getAddress(recoveredFrom).checksum;\n    } catch (error) {\n      throw error;\n    }\n    tx.rawTransaction = rawTransaction;\n    tx.id = keccak256(rawTransaction);\n  }\n\n  return tx;\n};\n\nexport const recoverETH = (rawTransaction: string) => {\n  const transaction = decode(rawTransaction);\n  if (transaction.length !== 9 && transaction.length !== 6) {\n    throw new Error('invalid rawTransaction');\n  }\n\n  const tx: TxParams = {\n    id: '0x',\n    from: '0x',\n    rawTransaction: '0x',\n    unsignedRawTransaction: '0x',\n    nonce: new BN(strip0x(handleNumber(transaction[0]))).toNumber(),\n    gasPrice: new BN(strip0x(handleNumber(transaction[1]))),\n    gasLimit: new BN(strip0x(handleNumber(transaction[2]))),\n    shardID: 0,\n    toShardID: 0,\n\n    to:\n      handleAddress(transaction[3]) !== '0x'\n        ? getAddress(handleAddress(transaction[3])).checksum\n        : '0x',\n    value: new BN(strip0x(handleNumber(transaction[4]))),\n    data: transaction[5],\n    chainId: 0,\n    signature: {\n      r: '',\n      s: '',\n      recoveryParam: 0,\n      v: 0,\n    },\n  };\n\n  // Legacy unsigned transaction\n  if (transaction.length === 6) {\n    tx.unsignedRawTransaction = rawTransaction;\n    return tx;\n  }\n\n  try {\n    tx.signature.v = new BN(strip0x(handleNumber(transaction[6]))).toNumber();\n  } catch (error) {\n    throw error;\n  }\n\n  tx.signature.r = hexZeroPad(transaction[7], 32);\n  tx.signature.s = hexZeroPad(transaction[8], 32);\n\n  if (\n    new BN(strip0x(handleNumber(tx.signature.r))).isZero() &&\n    new BN(strip0x(handleNumber(tx.signature.s))).isZero()\n  ) {\n    // EIP-155 unsigned transaction\n    tx.chainId = tx.signature.v;\n    tx.signature.v = 0;\n  } else {\n    // Signed Tranasaction\n\n    tx.chainId = Math.floor((tx.signature.v - 35) / 2);\n    if (tx.chainId < 0) {\n      tx.chainId = 0;\n    }\n\n    let recoveryParam = tx.signature.v - 27;\n\n    const raw = transaction.slice(0, 6);\n\n    if (tx.chainId !== 0) {\n      raw.push(hexlify(tx.chainId));\n      raw.push('0x');\n      raw.push('0x');\n      recoveryParam -= tx.chainId * 2 + 8;\n    }\n\n    const digest = keccak256(encode(raw));\n    try {\n      const recoveredFrom = recoverAddress(digest, {\n        r: hexlify(tx.signature.r),\n        s: hexlify(tx.signature.s),\n        recoveryParam,\n      });\n      tx.from = recoveredFrom === '0x' ? '0x' : getAddress(recoveredFrom).checksum;\n    } catch (error) {\n      throw error;\n    }\n    tx.rawTransaction = rawTransaction;\n    tx.id = keccak256(rawTransaction);\n  }\n\n  return tx;\n};\n\nexport const sleep = async (ms: number) =>\n  new Promise((resolve) => {\n    setTimeout(() => resolve(), ms);\n  });\n\nexport enum TransactionEvents {\n  transactionHash = 'transactionHash',\n  error = 'error',\n  confirmation = 'confirmation',\n  receipt = 'receipt',\n  track = 'track',\n  cxConfirmation = 'cxConfirmation',\n  cxReceipt = 'cxReceipt',\n  cxTrack = 'cxTrack',\n}\n\nexport const defaultMessenger = new Messenger(\n  new HttpProvider('http://localhost:9500'),\n  ChainType.Avalanche,\n);\n\nexport const RLPSign = (transaction: Transaction, prv: string): [Signature, string] => {\n  const [unsignedRawTransaction, raw] = transaction.getRLPUnsigned();\n  const regroup: TxParams = {\n    ...transaction.txParams,\n    unsignedRawTransaction,\n  };\n  transaction.setParams(regroup);\n  const signature = sign(keccak256(unsignedRawTransaction), prv);\n  const signed = transaction.getRLPSigned(raw, signature);\n  return [signature, signed];\n};\n","/**\n * @packageDocumentation\n * @module avalanche-transaction\n * @hidden\n */\n\nimport { BN, getAddress, AvalancheAddress } from 'avalanche-js-crypto';\nimport { hexToNumber } from 'avalanche-js-utils';\nimport { Messenger, RPCMethod, Emitter, HttpProvider, NewHeaders } from 'avalanche-js-network';\nimport { TxStatus, TransasctionReceipt } from './types';\nimport { sleep, TransactionEvents } from './utils';\nimport { AbstractTransaction } from './abstractTransaction';\n\nexport class TransactionBase implements AbstractTransaction {\n  static normalizeAddress(address: string) {\n    if (address === '0x') {\n      return '0x';\n    } else if (\n      AvalancheAddress.isValidChecksum(address) ||\n      AvalancheAddress.isValidBech32(address) ||\n      AvalancheAddress.isValidBech32TestNet(address)\n    ) {\n      return getAddress(address).checksum;\n    } else {\n      throw new Error(`Address format is not supported`);\n    }\n  }\n  emitter: Emitter;\n  messenger: Messenger;\n  txStatus: TxStatus;\n  blockNumbers: string[] = [];\n  confirmations: number = 0;\n  confirmationCheck: number = 0;\n  cxStatus: TxStatus = TxStatus.INTIALIZED;\n  cxBlockNumbers: string[] = [];\n  cxConfirmations: number = 0;\n  cxConfirmationCheck: number = 0;\n  receipt?: TransasctionReceipt;\n\n  id: string;\n  shardID: number | string;\n\n  constructor(messenger: Messenger, txStatus: TxStatus) {\n    this.messenger = messenger;\n    this.txStatus = txStatus;\n    this.emitter = new Emitter();\n    this.id = '0x';\n    this.shardID = this.messenger.currentShard;\n  }\n\n  setMessenger(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  setTxStatus(txStatus: TxStatus): void {\n    this.txStatus = txStatus;\n  }\n\n  getTxStatus(): TxStatus {\n    return this.txStatus;\n  }\n  setCxStatus(cxStatus: TxStatus): void {\n    this.cxStatus = cxStatus;\n  }\n\n  getCxStatus(): TxStatus {\n    return this.cxStatus;\n  }\n\n  // get status\n  isInitialized(): boolean {\n    return this.getTxStatus() === TxStatus.INTIALIZED;\n  }\n  isSigned(): boolean {\n    return this.getTxStatus() === TxStatus.SIGNED;\n  }\n  isPending(): boolean {\n    return this.getTxStatus() === TxStatus.PENDING;\n  }\n  isRejected(): boolean {\n    return this.getTxStatus() === TxStatus.REJECTED;\n  }\n  isConfirmed(): boolean {\n    return this.getTxStatus() === TxStatus.CONFIRMED;\n  }\n  isCxPending(): boolean {\n    return this.getCxStatus() === TxStatus.PENDING;\n  }\n  isCxRejected(): boolean {\n    return this.getCxStatus() === TxStatus.REJECTED;\n  }\n  isCxConfirmed(): boolean {\n    return this.getCxStatus() === TxStatus.CONFIRMED;\n  }\n  observed() {\n    return this.emitter;\n  }\n\n  async trackTx(txHash: string, shardID: number | string) {\n    if (!this.messenger) {\n      throw new Error('Messenger not found');\n    }\n    // TODO: regex validation for txHash so we don't get garbage\n    const res = await this.messenger.send(\n      RPCMethod.GetTransactionReceipt,\n      txHash,\n      this.messenger.chainType,\n      typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID,\n    );\n    if (res.isResult() && res.result !== null) {\n      this.receipt = res.result;\n      this.emitReceipt(this.receipt);\n      this.id = res.result.transactionHash;\n      this.confirmations += 1;\n\n      if (this.receipt) {\n        if (this.receipt.status && this.receipt.status === '0x1') {\n          this.receipt.byzantium = true;\n          this.txStatus = TxStatus.CONFIRMED;\n        } else if (this.receipt.status && this.receipt.status === '0x0') {\n          this.receipt.byzantium = true;\n          this.txStatus = TxStatus.REJECTED;\n        } else if (this.receipt.status === undefined && this.receipt.root) {\n          this.receipt.byzantium = false;\n          this.txStatus = TxStatus.CONFIRMED;\n        }\n        return true;\n      } else {\n        this.txStatus = TxStatus.PENDING;\n        const currentBlock = await this.getBlockNumber(shardID);\n\n        this.blockNumbers.push('0x' + currentBlock.toString('hex'));\n\n        this.confirmationCheck += 1;\n        return false;\n      }\n    } else {\n      this.txStatus = TxStatus.PENDING;\n      const currentBlock = await this.getBlockNumber(shardID);\n      this.blockNumbers.push('0x' + currentBlock.toString('hex'));\n      this.confirmationCheck += 1;\n      return false;\n    }\n  }\n\n  async txConfirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    interval: number = 1000,\n    shardID: number | string,\n  ) {\n    if (this.messenger.provider instanceof HttpProvider) {\n      this.txStatus = TxStatus.PENDING;\n      const oldBlock = await this.getBlockNumber(shardID);\n      let checkBlock = oldBlock;\n\n      for (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n        try {\n          const newBlock = await this.getBlockNumber(shardID);\n          // TODO: this is super ugly, must be a better way doing this\n          const nextBlock = checkBlock.add(new BN(attempt === 0 ? attempt : 1));\n\n          if (newBlock.gte(nextBlock)) {\n            checkBlock = newBlock;\n            this.emitTrack({\n              txHash,\n              attempt,\n              currentBlock: checkBlock.toString(),\n              shardID,\n            });\n\n            if (await this.trackTx(txHash, shardID)) {\n              this.emitConfirm(this.txStatus);\n              return this;\n            }\n          } else {\n            attempt = attempt - 1 >= 0 ? attempt - 1 : 0;\n          }\n        } catch (err) {\n          this.txStatus = TxStatus.REJECTED;\n          this.emitConfirm(this.txStatus);\n          throw err;\n        }\n\n        if (attempt + 1 < maxAttempts) {\n          // await sleep(interval * attempt);\n          await sleep(interval);\n        }\n      }\n      this.txStatus = TxStatus.REJECTED;\n      this.emitConfirm(this.txStatus);\n      throw new Error(`The transaction is still not confirmed after ${maxAttempts} attempts.`);\n    } else {\n      try {\n        if (await this.trackTx(txHash, shardID)) {\n          this.emitConfirm(this.txStatus);\n          return this;\n        } else {\n          const result = await this.socketConfirm(txHash, maxAttempts, shardID);\n          return result;\n        }\n      } catch (error) {\n        this.txStatus = TxStatus.REJECTED;\n        this.emitConfirm(this.txStatus);\n        throw new Error(\n          `The transaction is still not confirmed after ${maxAttempts * interval} mil seconds.`,\n        );\n      }\n    }\n  }\n\n  socketConfirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    shardID: number | string,\n  ): Promise<TransactionBase> {\n    return new Promise((resolve, reject) => {\n      const newHeads = Promise.resolve(\n        new NewHeaders(\n          this.messenger,\n          typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID,\n        ),\n      );\n      newHeads.then((p) => {\n        p.onData(async (data: any) => {\n          const blockNumber =\n            this.messenger.chainPrefix === 'hmy'\n              ? data.params.result.Header.number\n              : data.params.result.number;\n          this.emitTrack({\n            txHash,\n            attempt: this.confirmationCheck,\n            currentBlock: hexToNumber(blockNumber),\n            shardID,\n          });\n          if (!this.blockNumbers.includes(blockNumber)) {\n            if (await this.trackTx(txHash, shardID)) {\n              this.emitConfirm(this.txStatus);\n              await p.unsubscribe();\n              resolve(this);\n            } else {\n              if (this.confirmationCheck === maxAttempts) {\n                this.txStatus = TxStatus.REJECTED;\n                this.emitConfirm(this.txStatus);\n                await p.unsubscribe();\n                resolve(this);\n              }\n            }\n          }\n        }).onError(async (error: any) => {\n          this.txStatus = TxStatus.REJECTED;\n          this.emitConfirm(this.txStatus);\n          this.emitError(error);\n          await p.unsubscribe();\n          reject(error);\n        });\n      });\n    });\n  }\n\n  emitTransactionHash(transactionHash: string) {\n    this.emitter.emit(TransactionEvents.transactionHash, transactionHash);\n  }\n  emitReceipt(receipt: any) {\n    this.emitter.emit(TransactionEvents.receipt, receipt);\n  }\n  emitError(error: any) {\n    this.emitter.emit(TransactionEvents.error, error);\n  }\n  emitConfirm(data: any) {\n    this.emitter.emit(TransactionEvents.confirmation, data);\n  }\n  emitTrack(data: any) {\n    this.emitter.emit(TransactionEvents.track, data);\n  }\n  emitCxReceipt(receipt: any) {\n    this.emitter.emit(TransactionEvents.cxReceipt, receipt);\n  }\n  emitCxConfirm(data: any) {\n    this.emitter.emit(TransactionEvents.cxConfirmation, data);\n  }\n  emitCxTrack(data: any) {\n    this.emitter.emit(TransactionEvents.cxTrack, data);\n  }\n\n  async getBlockNumber(shardID: number | string): Promise<BN> {\n    try {\n      const currentBlock = await this.messenger.send(\n        RPCMethod.BlockNumber,\n        [],\n        this.messenger.chainPrefix,\n        typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID,\n      );\n      if (currentBlock.isError()) {\n        throw currentBlock.message;\n      }\n      return new BN(currentBlock.result.replace('0x', ''), 'hex');\n    } catch (error) {\n      throw error;\n    }\n  }\n  async getBlockByNumber(blockNumber: string) {\n    try {\n      const block = await this.messenger.send(\n        RPCMethod.GetBlockByNumber,\n        [blockNumber, true],\n        this.messenger.chainPrefix,\n        typeof this.shardID === 'string' ? Number.parseInt(this.shardID, 10) : this.shardID,\n      );\n      if (block.isError()) {\n        throw block.message;\n      }\n      return block.result;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async cxConfirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    interval: number = 1000,\n    toShardID: number | string,\n  ) {\n    if (this.messenger.provider instanceof HttpProvider) {\n      const oldBlock = await this.getBlockNumber(toShardID);\n      let checkBlock = oldBlock;\n\n      for (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n        try {\n          const newBlock = await this.getBlockNumber(toShardID);\n          // TODO: this is super ugly, must be a better way doing this\n          const nextBlock = checkBlock.add(new BN(attempt === 0 ? attempt : 1));\n\n          if (newBlock.gte(nextBlock)) {\n            checkBlock = newBlock;\n            this.emitCxTrack({\n              txHash,\n              attempt,\n              currentBlock: checkBlock.toString(),\n              toShardID,\n            });\n\n            if (await this.trackCx(txHash, toShardID)) {\n              this.emitCxConfirm(this.cxStatus);\n              return this;\n            }\n          } else {\n            attempt = attempt - 1 >= 0 ? attempt - 1 : 0;\n          }\n        } catch (err) {\n          this.cxStatus = TxStatus.REJECTED;\n          this.emitCxConfirm(this.cxStatus);\n          throw err;\n        }\n        if (attempt + 1 < maxAttempts) {\n          await sleep(interval);\n        }\n      }\n      this.cxStatus = TxStatus.REJECTED;\n      this.emitCxConfirm(this.cxStatus);\n      throw new Error(`The transaction is still not confirmed after ${maxAttempts} attempts.`);\n    } else {\n      try {\n        if (await this.trackCx(txHash, toShardID)) {\n          this.emitCxConfirm(this.cxStatus);\n          return this;\n        } else {\n          const result = await this.socketCxConfirm(txHash, maxAttempts, toShardID);\n          return result;\n        }\n      } catch (error) {\n        this.cxStatus = TxStatus.REJECTED;\n        this.emitCxConfirm(this.cxStatus);\n        throw new Error(\n          `The transaction is still not confirmed after ${maxAttempts * interval} mil seconds.`,\n        );\n      }\n    }\n  }\n\n  async trackCx(txHash: string, toShardID: number | string) {\n    if (!this.messenger) {\n      throw new Error('Messenger not found');\n    }\n    // TODO: regex validation for txHash so we don't get garbage\n    const res = await this.messenger.send(\n      RPCMethod.GetCXReceiptByHash,\n      txHash,\n      this.messenger.chainPrefix,\n      typeof toShardID === 'string' ? Number.parseInt(toShardID, 10) : toShardID,\n    );\n    if (res.isResult() && res.result !== null) {\n      this.emitCxReceipt(res.result);\n      this.cxStatus = TxStatus.CONFIRMED;\n      return true;\n    } else {\n      const currentBlock = await this.getBlockNumber(toShardID);\n      this.cxBlockNumbers.push('0x' + currentBlock.toString('hex'));\n      this.cxConfirmationCheck += 1;\n      this.cxStatus = TxStatus.PENDING;\n      return false;\n    }\n  }\n\n  socketCxConfirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    toShardID: number | string,\n  ): Promise<TransactionBase> {\n    return new Promise((resolve, reject) => {\n      const newHeads = Promise.resolve(\n        new NewHeaders(\n          this.messenger,\n          typeof toShardID === 'string' ? Number.parseInt(toShardID, 10) : toShardID,\n        ),\n      );\n      newHeads.then((p) => {\n        p.onData(async (data: any) => {\n          const blockNumber =\n            this.messenger.chainPrefix === 'hmy'\n              ? data.params.result.Header.number\n              : data.params.result.number;\n          this.emitCxTrack({\n            txHash,\n            attempt: this.cxConfirmationCheck,\n            currentBlock: hexToNumber(blockNumber),\n            toShardID,\n          });\n          if (!this.blockNumbers.includes(blockNumber)) {\n            if (await this.trackCx(txHash, toShardID)) {\n              this.emitCxConfirm(this.cxStatus);\n              await p.unsubscribe();\n              resolve(this);\n            } else {\n              if (this.cxConfirmationCheck === maxAttempts) {\n                this.cxStatus = TxStatus.REJECTED;\n                this.emitCxConfirm(this.cxStatus);\n                await p.unsubscribe();\n                resolve(this);\n              }\n            }\n          }\n        }).onError(async (error: any) => {\n          this.cxStatus = TxStatus.REJECTED;\n          this.emitCxConfirm(this.cxStatus);\n          this.emitError(error);\n          await p.unsubscribe();\n          reject(error);\n        });\n      });\n    });\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-transaction\n */\n\nimport {\n  BN,\n  encode,\n  arrayify,\n  hexlify,\n  stripZeros,\n  Signature,\n  splitSignature,\n} from 'avalanche-js-crypto';\nimport { add0xToString, numberToHex, ChainType, Unit } from 'avalanche-js-utils';\nimport { Messenger, RPCMethod } from 'avalanche-js-network';\nimport { TxParams, TxStatus } from './types';\nimport {\n  recover,\n  transactionFields,\n  defaultMessenger,\n  transactionFieldsETH,\n  recoverETH,\n} from './utils';\n\nimport { TransactionBase } from './transactionBase';\n\nclass Transaction extends TransactionBase {\n  /** @hidden */\n  private from: string;\n  /** @hidden */\n  private nonce: number | string;\n  /** @hidden */\n  private to: string;\n  // private shardID: number | string;\n  /** @hidden */\n  private toShardID: number | string;\n  /** @hidden */\n  private gasLimit: BN;\n  /** @hidden */\n  private gasPrice: BN;\n  /** @hidden */\n  private data: string;\n  /** @hidden */\n  private value: BN;\n  /** @hidden */\n  private chainId: number;\n  /** @hidden */\n  private rawTransaction: string;\n  /** @hidden */\n  private unsignedRawTransaction: string;\n  /** @hidden */\n  private signature: Signature;\n\n  /**\n   * \n   * @Params\n   * ```javascript\n   * id:               string;\n    from:             string;\n    to:               string;\n    nonce:            number | string;\n    gasLimit:         number | string | BN;\n    gasPrice:         number | string | BN;\n    shardID:          number | string;\n    toShardID:        number | string;\n    data:             string;\n    value:            number | string | BN;\n    chainId:          number;\n    rawTransaction:   string;\n    unsignedRawTransaction: string;\n    signature:        Signature;\n    receipt?:         TransasctionReceipt;\n   * ```\n   */\n  constructor(\n    params?: TxParams | any,\n    messenger: Messenger = defaultMessenger,\n    txStatus = TxStatus.INTIALIZED,\n  ) {\n    super(messenger, txStatus);\n    // intialize transaction\n    this.id = params && params.id ? params.id : '0x';\n    this.from = params && params.from ? params.from : '0x';\n    this.nonce = params && params.nonce ? params.nonce : 0;\n    this.gasPrice =\n      params && params.gasPrice\n        ? new Unit(params.gasPrice).asWei().toWei()\n        : new Unit(0).asWei().toWei();\n    this.gasLimit =\n      params && params.gasLimit\n        ? new Unit(params.gasLimit).asWei().toWei()\n        : new Unit(0).asWei().toWei();\n    this.shardID =\n      params && params.shardID !== undefined ? params.shardID : this.messenger.currentShard;\n    this.toShardID =\n      params && params.toShardID !== undefined ? params.toShardID : this.messenger.currentShard;\n\n    this.to = params && params.to ? Transaction.normalizeAddress(params.to) : '0x';\n    this.value =\n      params && params.value ? new Unit(params.value).asWei().toWei() : new Unit(0).asWei().toWei();\n    this.data = params && params.data ? params.data : '0x';\n    // chainid should change with different network settings\n    this.chainId = params && params.chainId ? params.chainId : this.messenger.chainId;\n    this.rawTransaction = params && params.rawTransaction ? params.rawTransaction : '0x';\n    this.unsignedRawTransaction =\n      params && params.unsignedRawTransaction ? params.unsignedRawTransaction : '0x';\n    this.signature =\n      params && params.signature\n        ? params.signature\n        : {\n            r: '',\n            s: '',\n            recoveryParam: 0,\n            v: 0,\n          };\n\n    this.receipt = params && params.receipt ? params.receipt : undefined;\n    this.cxStatus = this.isCrossShard() ? TxStatus.INTIALIZED : TxStatus.NONE;\n  }\n\n  /**\n   *\n   * @example\n   * ```javascript\n   * const unsigned = txn.getRLPUnsigned(txn);\n   * console.log(unsigned);\n   * ```\n   */\n  getRLPUnsigned(): [string, any[]] {\n    const raw: Array<string | Uint8Array> = [];\n\n    // temp setting to be compatible with eth\n    const fields =\n      this.messenger.chainType === ChainType.Avalanche ? transactionFields : transactionFieldsETH;\n\n    fields.forEach((field: any) => {\n      let value = (<any>this.txParams)[field.name] || [];\n      value = arrayify(\n        hexlify(field.transform === 'hex' ? add0xToString(value.toString(16)) : value),\n      );\n      // Fixed-width field\n      if (field.fix === true && field.length && value.length !== field.length && value.length > 0) {\n        throw new Error(`invalid length for ${field.name}`);\n      }\n\n      // Variable-width (with a maximum)\n      if (field.fix === false && field.length) {\n        value = stripZeros(value);\n        if (value.length > field.length) {\n          throw new Error(`invalid length for ${field.name}`);\n        }\n      }\n\n      raw.push(hexlify(value));\n    });\n\n    if (this.txParams.chainId != null && this.txParams.chainId !== 0) {\n      raw.push(hexlify(this.txParams.chainId));\n      raw.push('0x');\n      raw.push('0x');\n    }\n\n    return [encode(raw), raw];\n  }\n\n  getRLPSigned(raw: any[], signature: Signature): string {\n    // temp setting to be compatible with eth\n    const rawLength = this.messenger.chainType === ChainType.Avalanche ? 11 : 9;\n    const sig = splitSignature(signature);\n    let v = 27 + (sig.recoveryParam || 0);\n    if (raw.length === rawLength) {\n      raw.pop();\n      raw.pop();\n      raw.pop();\n      v += this.chainId * 2 + 8;\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r) || []));\n    raw.push(stripZeros(arrayify(sig.s) || []));\n\n    return encode(raw);\n  }\n\n  /**\n   * @example\n   * ```javascript\n   * console.log(txn.getRawTransaction());\n   * ```\n   */\n  getRawTransaction(): string {\n    return this.rawTransaction;\n  }\n\n  /** @hidden */\n  recover(rawTransaction: string): Transaction {\n    // temp setting to be compatible with eth\n    const recovered =\n      this.messenger.chainType === ChainType.Avalanche\n        ? recover(rawTransaction)\n        : recoverETH(rawTransaction);\n\n    this.setParams(recovered);\n    return this;\n  }\n\n  /**\n   * get the payload of transaction\n   *\n   * @example\n   * ```\n   * const payload = txn.txPayload;\n   * console.log(payload);\n   * ```\n   */\n  get txPayload() {\n    return {\n      from: this.txParams.from || '0x',\n      to: this.txParams.to || '0x',\n      shardID: this.txParams.shardID ? numberToHex(this.shardID) : '0x',\n      toShardID: this.txParams.toShardID ? numberToHex(this.toShardID) : '0x',\n      gas: this.txParams.gasLimit ? numberToHex(this.txParams.gasLimit) : '0x',\n      gasPrice: this.txParams.gasPrice ? numberToHex(this.txParams.gasPrice) : '0x',\n      value: this.txParams.value ? numberToHex(this.txParams.value) : '0x',\n      data: this.txParams.data || '0x',\n      nonce: this.txParams.nonce ? numberToHex(this.nonce) : '0x',\n    };\n  }\n\n  /**\n   * get transaction params\n   *\n   * @example\n   * ```\n   * const txParams = txn.txParams;\n   * console.log(txParams)\n   * ```\n   */\n  get txParams(): TxParams {\n    return {\n      id: this.id || '0x',\n      from: this.from || '',\n      nonce: this.nonce || 0,\n      gasPrice: this.gasPrice || new Unit(0).asWei().toWei(),\n      gasLimit: this.gasLimit || new Unit(0).asWei().toWei(),\n      shardID: this.shardID !== undefined ? this.shardID : this.messenger.currentShard,\n      toShardID: this.toShardID !== undefined ? this.toShardID : this.messenger.currentShard,\n      to: Transaction.normalizeAddress(this.to) || '0x',\n      value: this.value || new Unit(0).asWei().toWei(),\n      data: this.data || '0x',\n      chainId: this.chainId || 0,\n      rawTransaction: this.rawTransaction || '0x',\n      unsignedRawTransaction: this.unsignedRawTransaction || '0x',\n      signature: this.signature || {r:'', s:'', recoveryParam:0, v:0},\n    };\n  }\n\n  /**\n   * set the params to the txn\n   *\n   * @example\n   * ```\n   * txn.setParams({\n   *   to: 'avax1ew56rqrucu6p6n598fmjmnfh8dd4xpg6atne9c',\n   *   value: '1200',\n   *   gasLimit: '230000',\n   *   shardID: 1,\n   *   toShardID: 0,\n   *   gasPrice: new hmy.utils.Unit('101').asGwei().toWei(),\n   *   signature: {\n   *     r: '0xd693b532a80fed6392b428604171fb32fdbf953728a3a7ecc7d4062b1652c042',\n   *     s: '0x24e9c602ac800b983b035700a14b23f78a253ab762deab5dc27e3555a750b354',\n   *     v: 0\n   *   },\n   * });\n   * console.log(txn);\n   * ```\n   */\n  setParams(params: TxParams) {\n    this.id = params && params.id ? params.id : '0x';\n    this.from = params && params.from ? params.from : '0x';\n    this.nonce = params && params.nonce ? params.nonce : 0;\n    this.gasPrice =\n      params && params.gasPrice\n        ? new Unit(params.gasPrice).asWei().toWei()\n        : new Unit(0).asWei().toWei();\n    this.gasLimit =\n      params && params.gasLimit\n        ? new Unit(params.gasLimit).asWei().toWei()\n        : new Unit(0).asWei().toWei();\n    this.shardID =\n      params && params.shardID !== undefined ? params.shardID : this.messenger.currentShard;\n    this.toShardID =\n      params && params.toShardID !== undefined ? params.toShardID : this.messenger.currentShard;\n    this.to = params && params.to ? Transaction.normalizeAddress(params.to) : '0x';\n    this.value =\n      params && params.value ? new Unit(params.value).asWei().toWei() : new Unit(0).asWei().toWei();\n    this.data = params && params.data ? params.data : '0x';\n    this.chainId = params && params.chainId ? params.chainId : 0;\n    this.rawTransaction = params && params.rawTransaction ? params.rawTransaction : '0x';\n    this.unsignedRawTransaction =\n      params && params.unsignedRawTransaction ? params.unsignedRawTransaction : '0x';\n    this.signature =\n      params && params.signature\n        ? params.signature\n        : {\n            r: '',\n            s: '',\n            recoveryParam: 0,\n            v: 0,\n          };\n    if (this.rawTransaction !== '0x') {\n      this.setTxStatus(TxStatus.SIGNED);\n    } else {\n      this.setTxStatus(TxStatus.INTIALIZED);\n    }\n  }\n\n  /** @hidden */\n  map(fn: any) {\n    const newParams = fn(this.txParams);\n    this.setParams(newParams);\n\n    return this;\n  }\n\n  /**\n   * Check whether the transaction is cross shard\n   *\n   * @example\n   * ```javascript\n   * console.log(txn.isCrossShard());\n   * ```\n   */\n  isCrossShard(): boolean {\n    return new BN(this.txParams.shardID).toString() !== new BN(this.txParams.toShardID).toString();\n  }\n\n  /**\n   *\n   * @example\n   * ```\n   * txn.sendTransaction().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n\n  async sendTransaction(): Promise<[Transaction, string]> {\n    if (this.rawTransaction === 'tx' || this.rawTransaction === undefined) {\n      throw new Error('Transaction not signed');\n    }\n    if (!this.messenger) {\n      throw new Error('Messenger not found');\n    }\n\n    // const fromShard = this.shardID;\n    // const toShard = this.toShardID;\n    // await this.messenger.setShardingProviders();\n    const res = await this.messenger.send(\n      RPCMethod.SendRawTransaction,\n      this.rawTransaction,\n      this.messenger.chainType,\n      typeof this.shardID === 'string' ? Number.parseInt(this.shardID, 10) : this.shardID,\n    );\n\n    // temporarilly hard coded\n    if (res.isResult()) {\n      this.id = res.result;\n      this.emitTransactionHash(this.id);\n      this.setTxStatus(TxStatus.PENDING);\n      // await this.confirm(this.id, 20, 1000);\n      return [this, res.result];\n    } else if (res.isError()) {\n      this.emitConfirm(`transaction failed:${res.error.message}`);\n      this.setTxStatus(TxStatus.REJECTED);\n      return [this, `transaction failed:${res.error.message}`];\n    } else {\n      this.emitError('transaction failed');\n      throw new Error('transaction failed');\n    }\n  }\n\n  async confirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    interval: number = 1000,\n    shardID: number | string = this.txParams.shardID,\n    toShardID: number | string = this.txParams.toShardID,\n  ) {\n    const txConfirmed = await this.txConfirm(txHash, maxAttempts, interval, shardID);\n    if (!this.isCrossShard()) {\n      return txConfirmed;\n    }\n    if (txConfirmed.isConfirmed()) {\n      const cxConfirmed = await this.cxConfirm(txHash, maxAttempts, interval, toShardID);\n      return cxConfirmed;\n    } else {\n      return txConfirmed;\n    }\n  }\n}\nexport { Transaction };\n","/**\n * @packageDocumentation\n * @module avalanche-transaction\n * @hidden\n */\n\nimport { Messenger } from 'avalanche-js-network';\nimport { AddressSuffix } from 'avalanche-js-utils';\nimport { Transaction } from './transaction';\nimport { TxParams, TxStatus } from './types';\nimport { defaultMessenger } from './utils';\n\nexport class ShardingTransaction extends Transaction {\n  constructor(\n    params?: TxParams | any,\n    messenger: Messenger = defaultMessenger,\n    txStatus = TxStatus.INTIALIZED,\n  ) {\n    const fromAddress = params.from;\n    const toAddress = params.to;\n    const fromExtraction =\n      fromAddress !== undefined ? fromAddress.split(AddressSuffix) : ['0x', undefined];\n    const toExtraction =\n      toAddress !== undefined ? toAddress.split(AddressSuffix) : ['0x', undefined];\n    const from = fromExtraction[0];\n    const shardID =\n      fromExtraction[1] !== undefined\n        ? Number.parseInt(fromExtraction[1], 10)\n        : params.shardID !== undefined\n        ? params.shardID\n        : 0;\n    const to = toExtraction[0];\n    const toShardID =\n      toExtraction[1] !== undefined\n        ? Number.parseInt(toExtraction[1], 10)\n        : params.toShardID !== undefined\n        ? params.toShardID\n        : 0;\n\n    const reParams = {\n      ...params,\n      from,\n      to,\n      shardID,\n      toShardID,\n    };\n\n    super(reParams, messenger, txStatus);\n  }\n}\n","/**\n * ## hhahaha\n *\n * @packageDocumentation\n * @module avalanche-transaction\n */\n\nimport { getContractAddress, getAddress } from 'avalanche-js-crypto';\nimport { Messenger } from 'avalanche-js-network';\nimport { Transaction } from './transaction';\nimport { ShardingTransaction } from './shardingTransaction';\nimport { TxParams, TxStatus } from './types';\n\nexport class TransactionFactory {\n  static getContractAddress(tx: Transaction) {\n    const { from, nonce } = tx.txParams;\n    return getAddress(\n      getContractAddress(getAddress(from).checksum, Number.parseInt(`${nonce}`, 10)),\n    ).checksum;\n  }\n\n  messenger: Messenger;\n  constructor(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n  setMessenger(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  /**\n   * Create a new Transaction\n   * @params\n   * ```\n   * // to: Address of the receiver\n   * // value: value transferred in wei\n   * // gasLimit: the maximum gas would pay, can use string\n   * // shardID: send token from shardID\n   * // toShardId: send token to shardID\n   * // gasPrice: you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n   * ```\n   *\n   * @example\n   * ```javascript\n   * const txn = hmy.transactions.newTx({\n   *   to: 'avax166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n   *   value: '10000',\n   *   gasLimit: '210000',\n   *   shardID: 0,\n   *   toShardID: 0,\n   *   gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n   * });\n   * ```\n   */\n  newTx(txParams?: TxParams | any, sharding: boolean = false): Transaction {\n    if (!sharding) {\n      return new Transaction(txParams, this.messenger, TxStatus.INTIALIZED);\n    }\n    return new ShardingTransaction(txParams, this.messenger, TxStatus.INTIALIZED);\n  }\n\n  /**\n   * clone the transaction\n   *\n   * @param transaction\n   *\n   * @example\n   * ```javascript\n   * const cloneTxn = hmy.transactions.clone(txn);\n   * console.log(cloneTxn)\n   * ```\n   */\n  clone(transaction: Transaction): Transaction {\n    return new Transaction(transaction.txParams, this.messenger, TxStatus.INTIALIZED);\n  }\n\n  /**\n   *\n   * @example\n   * ```javascript\n   * txHash = '0xf8698085174876e8008252088080949d72989b68777a1f3ffd6f1db079f1928373ee52830186a08027a0ab8229ff5d5240948098f26372eaed9ab2e9be23e8594b08e358ca56a47f8ae9a0084e5c4d1fec496af444423d8a714f65c079260ff01a1be1de7005dd424adf44'\n   *\n   * const recoverTx = hmy.transactions.recover(txHash);\n   * console.log(recoverTx);\n   * ```\n   */\n  recover(txHash: string): Transaction {\n    const newTxn = new Transaction({}, this.messenger, TxStatus.INTIALIZED);\n    newTxn.recover(txHash);\n    return newTxn;\n  }\n}\n"],"names":["TxStatus","TransactionEvents","transactionFields","name","length","fix","transform","transactionFieldsETH","handleNumber","value","isHex","hexToNumber","handleAddress","isAddress","recover","rawTransaction","transaction","decode","Error","tx","id","from","unsignedRawTransaction","nonce","BN","strip0x","toNumber","gasPrice","gasLimit","shardID","toShardID","to","getAddress","checksum","data","chainId","signature","r","s","recoveryParam","v","error","hexZeroPad","isZero","Math","floor","raw","slice","push","hexlify","digest","keccak256","encode","recoveredFrom","recoverAddress","recoverETH","sleep","ms","Promise","resolve","setTimeout","defaultMessenger","Messenger","HttpProvider","ChainType","Avalanche","TransactionBase","messenger","txStatus","INTIALIZED","emitter","Emitter","this","currentShard","normalizeAddress","address","AvalancheAddress","isValidChecksum","isValidBech32","isValidBech32TestNet","setMessenger","setTxStatus","getTxStatus","setCxStatus","cxStatus","getCxStatus","isInitialized","isSigned","SIGNED","isPending","PENDING","isRejected","REJECTED","isConfirmed","CONFIRMED","isCxPending","isCxRejected","isCxConfirmed","observed","trackTx","txHash","send","RPCMethod","GetTransactionReceipt","chainType","Number","parseInt","res","isResult","result","receipt","emitReceipt","transactionHash","confirmations","status","byzantium","undefined","root","getBlockNumber","blockNumbers","toString","confirmationCheck","txConfirm","maxAttempts","interval","provider","checkBlock","attempt","newBlock","nextBlock","add","gte","emitTrack","currentBlock","emitConfirm","socketConfirm","reject","NewHeaders","_this","then","p","onData","blockNumber","chainPrefix","params","Header","number","includes","unsubscribe","onError","emitError","emitTransactionHash","emit","confirmation","track","emitCxReceipt","cxReceipt","emitCxConfirm","cxConfirmation","emitCxTrack","cxTrack","BlockNumber","isError","message","replace","getBlockByNumber","GetBlockByNumber","block","cxConfirm","trackCx","socketCxConfirm","GetCXReceiptByHash","cxBlockNumbers","cxConfirmationCheck","_this2","Transaction","Unit","asWei","toWei","isCrossShard","NONE","getRLPUnsigned","forEach","field","txParams","arrayify","add0xToString","stripZeros","getRLPSigned","rawLength","sig","splitSignature","pop","getRawTransaction","recovered","setParams","map","fn","newParams","sendTransaction","SendRawTransaction","confirm","txConfirmed","numberToHex","gas","ShardingTransaction","fromAddress","toAddress","fromExtraction","split","AddressSuffix","toExtraction","reParams","_Transaction","TransactionFactory","getContractAddress","newTx","sharding","clone","newTxn","prv","regroup","sign"],"mappings":"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"}